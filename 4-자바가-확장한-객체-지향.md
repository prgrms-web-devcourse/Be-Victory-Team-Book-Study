# 자바가 확장한 객체 지향
## 추상 클래스
자바에서는 abstract 키워드를 이용하여 추상 클래스를 정의할 수 있다.
추상 클래스는 바디가 정의되지 않은 추상 메서드를 가진 클래스로 직접 객체를 생성할 수 없다.
대신 이를 상속받은 자식 클래스를 생성하여 추상 클래스 타입으로 참조하는 것은 가능하다.

이는 부모 클래스의 기능을 자식 클래스에서 재정의하도록 강제하고 실수로라도 기능이 완전히 구현되지 않은 부모 클래스를 생성해서 사용하는 일이 없도록 보장한다.

## 생성자
별도의 생성자를 구현하면 기본 생성자(파라미터가 없는 생성자)는 등록되지 않는다는 것에 유의.

## 스태틱 블록
자바 클래스가 static 영역에 배치될 때 실행되는 블록이다. 정적 필드에는 접근할 수 있지만 아직 객체가 생성되지 않았기 때문에 멤버 필드에는 접근할 수 없다.
자바 클래스는 `import` 되는 것이 아니라 실제로 사용될 때 static 영역에 등록되기 때문에 아예 참조되지 않는 클래스라면 스태틱 블록의 코드는 실행되지 않는다.
반대로 동일한 자바 클래스가 여러번 참조(생성자 호출, 정적 필드 참조, 정적 메서드 호출 등)되더라도 스태틱 블록의 코드는 단 한번만 실행된다.

이를 활용하는 예시로 JUnit의 `@BeforeClass` 가 있다고 한다.

`static` 키워드가 붙지 않은 블록은 객체 블록이 된다. 이 블록은 객체가 생성될 때 생성자보다 먼저 실행된다.

## final
자바에서는 클래스, 메서드, 필드에 final 키워드를 붙일 수 있다. 붙는 곳에 따라 각자 역할이 다른데 다음과 같다.
### 클래스
final 클래스는 상속을 허락하지 않겠다는 것을 명시한다.
### 메서드
final 메서드는 재정의(오버라이딩)를 허용하지 않겠다는 것을 명시한다.
### 필드
final 필드는 무조건 클래스 또는 객체 생성 시 초기화되어야 하며 한 번 초기화한 후 값을 수정할 수 없다는 것을 명시한다. 
static final 필드는 필드 정의 시 값을 부여하거나 앞서 언급한 스태틱 블록에서 초기화할 수 있다.

## instanceof
객체가 특정 클래스의 인스턴스 또는 특정 인터페이스의 구현체인지 확인할 수 있는 키워드다. 상속 관계의 객체라도 참조 타입이 아닌 실제 타입으로 판단한다.
_이 키워드를 많이 사용하면 LSP를 위반한다고 하는데 그 이유는?_

## package
자바 클래스가 속할 네임스페이스를 지정하는 키워드다. C++의 `namespace` 처럼 특정 클래스의 소유자를 명시하여 같은 이름의 클래스가 있을 때 구분할 수 있도록 한다.

## interface, implements
자바의 인터페이스는 기본적으로 구현되지 않은 public 메서드와 정적 상수(static final)만 가질 수 있다. 따로 접근 지정자나 final 키워드를 적용할 필요는 없다.
중요한 점은 자바 8 이후부터 인터페이스에도 디폴트 메서드로 미리 구현된 메서드를 가질 수 있도록 허용하였다.

## this
객체가 자기 자신을 지칭하는 키워드다. 메서드 내에서 블록 내의 변수가 아닌 클래스의 변수를 참조하고 싶다면 사용할 수 있다.

_JVM은 클래스의 메서드를 static 영역에 하나만 만들어두고 실제 호출 시 메서드 파라미터로 해당 클래스의 this 를 넘긴다고 하는데 이게 무슨 내용인지?_

## super
객체가 자신의 상위 클래스의 인스턴스를 가리키는 키워드다.
