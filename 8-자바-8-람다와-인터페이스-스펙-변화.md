# 자바 8 람다와 인터페이스 스펙 변화
Java 8의 가장 큰 변화 중 하나는 람다 표현식을 활용한 함수형 인터페이스 지원이다.

## 왜 람다를 사용하는가?
옛날과 달리 PC의 하드웨어 성능이 증가(멀티코어)하면서 병렬 처리를 활용할 수 있는 요구사항이 등장하게 되었다. 그리고 IT 서비스에서 대용량 데이터를 활용하게 되면서 이를
효율적으로 처리할 수 있는 방안이 요구되었다. 여기서 배치(Batch)와 스트림 처리(Stream-Processing)를 활용하여 병렬 처리를 통해 대용량 데이터를 동시에 다루면서
실시간 처리(real-time processing)를 통해 처리된 데이터를 받을 수 있는 방법이 람다 아키텍처다.

위와 같은 요구사항은 Java에게도 요구되었다. 그래서 Java 8에서는 데이터를 담는 클래스인 컬렉션 클래스의 병렬 처리를 강화했는데 스트림 연산, 람다 표현식을 추가하여 대용량 데이터를
다룰 수 있도록 하였다. 람다 표현식은 이전의 메서드 호출이나 익명 객체와는 달리 함수 자체만으로도 다른 함수의 반환값이나 파라미터로 사용할 수 있다.
그렇기 때문에 컬렉션 클래스의 스트림 연산에 활용할 수 있으며 이는 기존의 반복문을 통한 메서드 호출보다 더 간편하고 빠르게 처리할 수 있다. 
그리고 로직을 메서드가 아닌 람다로 구현하여 함수형 프로그래밍 패러다임에도 좀 더 가까워졌다고 할 수 있다.

## 함수형 인터페이스
Java에서 람다 표현식은 함수형 인터페이스(`@FunctionalInterface`)라는 단 하나의 메서드만 정의한 인터페이스를 기반으로 동작한다. 함수형 인터페이스는 메서드가 하나만 있기 때문에
컴파일러가 매개변수와 반환값만으로 이루어진 람다 표현식을 보고 어떤 인터페이스 메서드인지 추정할 수 있다. 대표적으로 `Runnable` 인터페이스가 이에 해당한다. 그래서 이 인터페이스 
메서드의 구현체를 람다 표현식으로 나타내면 함수형 인터페이스의 객체처럼 다루고 해당 인터페이스를 받아서 메서드를 호출하거나 반환 타입으로 사용하는 곳에서 사용할 수 있다.

기존의 OOP에서 클래스로 나타내던 익명 객체 방식과는 달리 한 행위를 나타내는 재사용 가능한 작은 함수로 다룰 수 있기 때문에 불필요한 반복되는 코드(클래스 생성, `@Override` 등)를 줄일 수 있다.
또한 Java에서는 재사용성을 위해 자주 사용될 수 있는 함수형 인터페이스를 몇 가지 정의해두었는데 그 중 몇 개는 다음과 같다.
- Runnable: no arg. no return value.
- Supplier<T\>: no arg. T return value.
- Consumer<T\>: T arg. no return value.
- Function<T, R\>: T arg. R return value.
- Predicate<T\>: T arg. boolean return value.
- UnaryOperator<T\>: T arg. T return value.

## 인터페이스 스펙 변화
Java 8로 넘어오면서 인터페이스에도 default method를 구현할 수 있게 됐다. 이는 하위 호환성을 위한 것인데 Java 8에서 컬렉션 API를 변경하면서 많은 메서드가 추가되고 변경되었다.
그러나 인터페이스 특성상 메서드가 변경되면 이를 구현하는 구현체에 모두 영향이 가기 때문에 구현을 강제하지 않도록 default method란 개념을 추가하여 인터페이스 스펙을 갱신한 것이다.
  
## 람다는 어떻게 컴파일되는가?
만약 람다가 단순히 표현 형태만 간단해지고 실제로는 익명 객체를 생성한다고 하면 그렇게 각광받을 이유는 없었을 것이다. 람다 표현식은 특정 클래스의 인스턴스로 생성되는 게 아니라
컴파일 과정에서 JVM 수준의 명령어로 변환된다. 이는 Java 7에서 지원된 기능으로 실행 시점에 람다 표현식의 역할, 즉 바이트 코드를 생성한다. 컴파일러는 람다 표현식을
실제로 어떻게 생성하면 될 지 방법(Java 7 API)만 정의해주고 실제 실행 시점에 표현식의 바디, 즉 코드가 `private`한 메서드로 생성되어 호출된다.

# 참고
[위키피디아 - Lambda Architecture](https://en.wikipedia.org/wiki/Lambda_architecture)
[What Lambda Expressions are compiled to? What is their runtime behavior?](https://www.logicbig.com/tutorials/core-java-tutorial/java-8-enhancements/java-lambda-functional-aspect.html)
