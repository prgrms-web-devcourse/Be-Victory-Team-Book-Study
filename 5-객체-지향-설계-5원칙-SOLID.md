# 5-객체-지향-설계-5원칙-SOLID.md
SOLID는 객체 지향 패러다임을 올바르게 반영하여 객체 지향 프로그램을 작성하기 위한 5대 원칙의 두문자어다.
여러가지 원칙이 있지만 결과적으로는 응집도를 높이고 결합도를 낮춰서 모듈 간 상호 의존도를 떨어뜨리고 수정, 유지보수를 용이하게 하는 것이 궁극적인 목적이 된다.

## Single Responsibility Principle
단일 책임 원칙. 특정 클래스는 오직 하나의 책임을 가지고 역할을 수행하며 이 클래스를 변경해야 한다면 오직 이 책임, 역할의 관점에서만 허용한다.
하나의 책임만 가지는 클래스는 변경이 일어났을 때 관련없는 클래스까지 영향을 끼치지 않는다.

만약 여러 책임을 가지는 클래스가 하나로 묶여있다면 데이터베이스 테이블 자체도 난잡해질뿐더러 특정 관점에서 다른 관점의 필드에 접근하는 것을 제한할 수 없다.
그렇기 때문에 if-else 같은 분기문에서 클래스를 좀 더 세분화할 수 있는 단서를 찾아보는 것이 좋다.

이 단일 책임 원칙은 모델링(추상화) 과정에서 고려해야 한다.

[ZDNET 기사](https://zdnet.co.kr/view/?no=00000039135552)

## Open-Closed Principle
개방 폐쇄 원칙. 확장에는 열려(open)있지만 변경에는 닫혀(closed)있어야 한다는 원칙이다.
이게 무슨 소린가 싶지만 추상 클래스와 구현 클래스로 생각할 수 있다. 추상 클래스는 실제로 기능이 구현된 구현 클래스로 구체화하거나 역할에 따른 속성이 추가된
하위 추상 클래스를 정의하는 방식으로 확장할 수 있다. 그렇지만 하위 클래스에서 어떻게 확장하던지 간에 추상 클래스의 역할과 속성 자체는 변하지 않는다.
즉 확장에는 열려 있지만 변경에는 닫혀 있는 것이다.

클라이언트 측 역시 개방 폐쇄 원칙을 잘 지킨 클래스라면 자신이 인지하지 못한 사이에 변경되는 것을 걱정할 필요가 없고 다양한 확장 클래스도 유연하게 다룰 수 있다는 장점이 있다.

[ZDNET 기사](https://zdnet.co.kr/view/?no=00000039134727)

## Liskov Substitution Principle
하위 타입은 언제나 상위 타입으로 교체해서 그의 역할을 수행할 수 있어야 한다는 원칙이다.

앞서 언급했듯이 상속은 상하관계가 아니라 'is a kind of', 확장관계라고 할 수 있는데 이를 준수한다면 LSP 역시 준수할 수 있다.
상하관계는 상위 타입의 역할을 하위 타입에서 수행할 수가 없는 경우(사장-직원, 부모-자식)가 대부분이기 때문에 상속 관계에는 적절하지 않다. 즉 하위 타입이 상위타입으로
교체되어 이의 역할을 수행할 수 없다는 것이다. 그러나 확장 관계의 경우 상위 타입의 책임과 역할을 그대로 가져오고 하위 타입에서 구체적인 필드를 추가했기 때문에
상위 타입의 역할을 문제없이 수행할 수 있다.

LSP에서는 상위 클래스가 갖고 있는 공통 필드가 풍부할수록 하위 클래스가 다시 추가해야 할 공통 필드가 줄어들기 때문에 상위 타입이 거대한 것이 좋다.
상위 타입으로 참조할 때도 하위 타입에서 추가된 속성을 참조하기 위해 `instanceof`와 if-else 같은 분기문, 형변환을 통해 복잡한 과정을 거칠 필요가 없기 때문이다.

## Interface Segregation Principle
인터페이스 분리 원칙. SRP처럼 책임에 따라 클래스를 분할하기 적절하지 않은 클래스의 경우 Java의 인터페이스같은 기능을 활용해 역할을 분리할 수 있다.
같은 문제에 대한 서로 다른 해결방법이라 할 수 있는데 전자가 아예 클래스 자체를 별도로 분리했다면 후자는 같은 클래스를 서로 다른 인터페이스로 접근하여 다루는 것이다.

이런 인터페이스를 정의하여 부여할 때 주의할 점은 인터페이스의 역할(Java로 치면 메서드의 갯수)을 최소화하고 정확하게 맞추라는 것이다. 인터페이스의 역할이 세분화되어있을수록
해당 객체가 수행할 수 있는 기능(is able to)이 명확해지고 변경에 강건해질 수 있기 때문이다.

## Dependency Inversion Principle
의존관계 역전 원칙. 추상체가 구현체에 의존하면 안 되고 구현체가 추상체에 의존해야 한다는 것이다. 특히 구체(concrete) 클래스는 자주 변경될 수 있으니 이곳에 의존하지 않는 것이다.
간단하게 말하면 어떤 인터페이스나 추상 클래스같은 추상체가 있고 이를 구현한 구현체가 있을때(마치 OCP) 클라이언트에서는 이 구현체보다 추상체에 의존해야 한다는 것이다. 그래서
구현체가 변경되더라도 클라이언트는 그 구체적인 변경 내역에 영향을 받지 않는 유연한 상태를 가질 수 있다.

즉 자신보다 변하기 쉬운 것에는 의존하지 않는 것이 좋다는 것이 된다.
