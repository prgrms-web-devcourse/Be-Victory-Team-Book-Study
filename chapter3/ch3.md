# Ch3. 자바와 객체 지향


## 객체 지향은 인간 지향이다
  
---  

> 객체 지향이 현실 세계를 반영한다는 말은 필자가 한 말이 아니고 이미 오래 전에 객체 지향 언어의 틀을 만든 누군가가 한 말이다. "그럼 그 증거는 뭐냐?" 라고 묻는다면 그 증거는 바로 **객체**다.
>

⇒ 기계 중심의 언어였던 기계어에서 인간도 이해할 수 있는 언어로 발전해가는 과정 중에 객체 지향 언어가 있다. 바로 **우리 주변에서 우리가 사물을 인지하는대로 프로그래밍 할 수 있지 않을까**? 에서 출발하여 '객체 지향 언어'가 탄생하였다.

> 그래서 객체 지향은 **직관적**이다.  
사람은 사물을 하나하나 이해하기 보다 사물을 분류(Class) 해서 이해하는 것이 인간의 인지법이다.
>

⇒ **사람** 이라는 것을 사물로 **분류**한다고 하면, **특정인** 들은 각 **객체**라고 할 수 있다.

i.e. 김종민, 한효주, 김연아 → 객체

## 객체 지향의 4대 특성 - 캡!상추다
  
---  

- 캡슐화 (Encapsulation) : 정보 은닉(Information hiding)
- 상속 : 재사용
- 추상화(Abstraction) : 모델링
- 다형성(Polymorphism) : 사용 편의

⇒ 4가지의 특성을 기존에 있는 개념적인 용어와 우리가 이해하기 쉬운 언어로 매핑해서 정리했다.

## 클래스 VS 객체 = 붕어빵틀 VS 붕어빵 ????
  
---  

> 붕어빵틀 붕어빵 = new 붕어빵틀();
>
> 금형기계 붕어빵틀 = new 금형기계();


⇒ 위의 코드는 클래스와 객체를 설명하기에 더 헷갈리게 하는 코드이다.

⇒ 붕어빵 틀은 붕어빵을 만드는 **팩토리**이다.

> **클래스**는 **분류에 대한 개념**이지 실체가 아니다. **객체**는 **실체**다. 그러면 이제 붕어빵틀과 붕어빵이라는 잘못된 메타포 대신 필자가 올바른 메타포를 제시하겠다.
>

⇒ 사람(개념) 이라는 분류 안에 강호동, 아이유, 배트맨, 이병헌, 우리 아빠 등의 객체들이 있는 것이다.

## 추상화 : 모델링
  
---  

⇒ **공통 특성 , 공통 속성 추출** 을 주목하여 추상화를 정리해보자.

- 추상화는 모델링이다.

  > 추상화란 **구체적인 것을 분해**해서 **관찰자가 관심 있는 특성만 가지고 재조합**하는 것이라고 정리할 수 있다.
  >

  > 추상화란 구체적인 것을 분해해서 **관심 영역(애플리케이션 경계, Context) 에 있는 특성만 가지고 재조합**하는 것 **= 모델링**.
  >

  i.e. 병원 어플리케이션에서 **사람은 환자**고, 은행 어플리케이션에서의 **사람은 고객**이다.


- 추상화와 T 메모리

⇒ UML 표기법에서 클래스 멤버는 밑줄을, 객체 멤버는 밑줄 없이 표현하기로 합의했다. 클래스 멤버와 객체 멤버를 구분하는 자바 키워드는 static이다.

⇒ 각 **클래스는 스태틱 영역의 메모리가 할당**되어 있고, new 생성자()를 하는 순간, 클래스의 **인스턴스(객체)는 힙 영역의 메모리에 할당**이 되고 **스택 영역**에 있는 **객체 참조 변수는 인스턴스의 주소값을 참조**한다.

- 스태틱 (Static) : main 메소드가 시작되기 전에 올라가서 main() 메소드가 종료된 후에 내려올 정도로 스태틱 영역에 단단히 고정돼 있다는 뜻으로 스태틱 영역이라고 한다.
- 스택 (Stack) : 선입후출 구조, LIFO, FILO와 관련되엉 있는 자료구조.
- 힙 (Heap) : 대용량 자료를 저장할 수 있도록 메모리를 사용하는 방식.


- 클래스 멤버 VS 객체 멤버 = static 멤버 VS 인스턴스 멤버

⇒ 미키마우스(객체)의 꼬리는 몇개? 제리(객체)의 꼬리는 몇개? 쥐(클래스)의 꼬리는 몇개?

⇒ 이처럼 **인스턴스(객체)와 상관없이 고정되는 value**가 있다면, 클래스 멤버 즉, **static 필드**로 작성할 수 있다. 그래서 **static 영역에 메모리로 할당**된다.

⇒ 그럼 **static 메소드**는 ? 실무에서는 **클래스의 인스턴스를 만들지 않고 사용하게 되는 유틸성 메소드**를 주로 정적 메소드로 구성한다.

이름 | 다른 이름 | 사는 곳
  ----- | ----------| --------
static 변수 | 클래스 [멤버]속성, 정적 변수, 정적 속성....| 스태틱 영역
인스턴스 변수 | 객체 [멤버]속성, 객체 변수.... | 힙 영역
local 변수 | 지역 변수 | 스택영역(스택 프레임 내부)


## 상속 : 재사용 + 확장
  
---  

> 객체 지향에서의 상속은 상위 클래스의 **특성을 하위 킄ㄹ래스에서 상속(특성 상속**)하고 거기에 **더해 필요한 특성을 추가, 즉 확장**해서 사용할 수 있다는 의미이다.  
앞으로는 상속을 부모 클래스, 자식 클래스 표현보다는 **상위 클래스 - 하위 클래스** 또는 **슈퍼 클래스 - 서브 클래스**라고 표현하자.  
상위 분류, 하위 분류라고 이해해도 좋다. 그리고 **상위 클래스 쪽으로 갈수 추상화, 일반화**됐다고 말하며, **하위 클래스 쪽으로 갈수록 구체화, 특수화**됐다고 말한다.
>

하위 클래스(포유류)는 상위 클래스(동물) 이다.

⇒ 객체 지향 설계 5원칙 가운데 LSP(리스코프 치환 원칙) 을 나타내는 말이다.

- 상속의 강력함

⇒ extends를 받은 하위 클래스는 상위 클래스의 메소드를 그대로 쓸 수 있다.

- 상속은 is a 관계를 만족해야 한다? : 상속은 **is a kind of** 관계 를 만족해야 한다.

  ⇒ 하위 클래스 is **a kind of 상위 클래스**

  i.e. 펭귄 is a kind of 동물 → 펭귄은 동물의 한 분류이다.

- 다중상속과 자바

⇒ 득보다 실이 많은 다중 상속은 없고 대신 interface를 도입했다.

- 상속과 인터페이스

⇒ 인터페이스는 상속과는 다르게 쓰는 것이 유용하다.

⇒ 구현 클래스 **is able to 인터페이스**

i.e. 고래는 헤엄칠 수 있다.

⇒ 자바 API 에서도 "be able to" 형식의 인터페이스를 볼 수 있다.

i.e. Serializable, Clonable, Comparable, Runnable

⇒ **상위클래스는 물려줄 특성(속성, 메소드)이 풍성할수록 좋고(LSP, 리스코프 치환 원칙)**, 인터페이스는 **구현을 강제할 메소드의 개수가 적을수록 좋다(ISP, 인터페이스 분할 원칙)**.

- 상속과 T 메모리

⇒ 하위 클래스의 인스턴스를 생성하게 되면 상위 클래스 인스턴스도 함께 힙 메모리에 생성된다. 그리고 모든 인스턴스는 Object의 하위 클래스이므로 Object 인스턴스도 힙 영역에 할당된다.

⇒ Type을 상위 클래스로 선언하느냐, 하위 클래스로 선언하느냐에 따라 사용할 수 있는 속성과 메소드가 다르다. : **상위 클래스 객체는 하위 클래스 객체의 속성과 메소드를 사용할 수 없다. 확장되지 않는 상태이기 때문에.**


## 다형성 : 사용편의성
  
---  

> 객체 지향에서 다형성이라고 하면 **오버라이딩(overriding)** 과 **오버로딩(overloading)**이라고 할 수 있다.
>
- 다형성과 T 메모리

⇒ 하위 클래스에서 메소드를 오버라이딩 했다면, 메모리 상에 만들어진 **상위클래스 인스턴스에서 오버라이딩된 메소드가 덮어써진다**.

⇒ 오버로딩 된 메소드는 각 인스턴스 메모리 안에 쌓여있다.

- 다형성이 지원되지 않는 언어

  > 오버로딩은 함수명 하나를 가지고 인자 목록만 달리하면 되니 얼마나 사용하기 편리한지 알 수 있다. 특히 자바 5에서 추가된 제네릭을 이용하면 하나의 함수만 구현해도 다수의 함수를 구현한 효과를 낼 수 있다.
>


## 캡슐화 : 정보 은닉
  
---  

> 자바에서 정보 은닉(information hiding) 이라고 하면 접근 제어자인 private, [default], protected, public 이 생각날 것이다. 그리고 접근자 및 설정자 메소드도 머릿속을 스쳐 지나갈 것이다. **접근 제어자가 객체 멤버(인스턴스 멤버)와 쓰일 때와 정적 멤버(클래스 멤버) 와 함께 쓰일 때를 비교**해보자.
>

[oopinspring/ClassAB.java at master · expert0226/oopinspring](https://github.com/expert0226/oopinspring/blob/master/workspace_springjava/Chap03/src/encapsulation01/packageTwo/ClassAB.java)

## 참조 변수의 복사
  
---  

> Call by Value에 의해 변수를 복사하든 Call By Reference에 의해 참조 변수를 복사하든 결국은 **변수가 가진 값이 그대로 복사된다는 것을 알 수 있다**. 다만 그 값을 값 자체로 해석하느냐 아니면 주소값으로 해석하느냐의 차이일뿐이다.
>