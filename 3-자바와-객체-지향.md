# 자바와 객체 지향

요구 사항을 Divide & Conquer 하여 잘게 나눠서 함수로 처리하던 구조적 방식에서 현실 세계의 특징을 반영하여 객체 간 협력 관계를 통해 문제를 해결하는 새로운 프로그래밍 패러다임이 객체 지향 프로그래밍이라 할 수 있다.

클래스와 객체는 붕어빵틀과 붕어빵이 아닌 개념과 실체의 관계라고 할 수 있다. 클래스가 속성과 행위를 갖고 있다면 객체는 해당 속성과 행위를 가진 의미있는 고유한 무언가라고 할 수 있다.

객체의 클래스를 디자인, 즉 모델링하는 과정은 추상화라고 할 수 있다. 다양한 속성과 동작을 수행할 수 있는 객체들을 목적에 따라 관심 있는 특성만 추출해서 클래스로 조합하는 것이다. 객체를 어떻게 추상화, 즉 모델링하는 지는 데이터베이스 테이블까지 연관되기 때문에 중요한 작업이다.

모든 객체에서 동일하게 참조하거나 사용하는 값은 정적 변수로 두는 것이 좋다. 이는 스태틱 메모리 영역에 생성되며 객체의 필드 값은 동적으로 생성된 객체니 힙 영역에, 호출된 메서드 내에서 사용하는 지역 변수는 스택 프레임 즉 스택 영역에 존재하게 된다.

객체 지향의 상속은 사실 어떤 구분된 하위, 상위 관계를 가진 현실 세계의 상속보다 확장과 재사용으로 판단하는 것이 옳다. 즉 상위 클래스의 특성을 하위 클래스에 등록하여 재사용하고 거기에 추가적으로 구체적인 특성을 정의하는 것이다. 그러면 확장이기 때문에 상위 타입의 역할을 하위 타입이 문제없이 수행할 수 있다.

상속 관계는 `is a`보다는 `is a kind of`로 표현하는 편이 옳다.

Java가 C++과 달리 다중 상속을 지원하지 않는 것은 다중 상속이 내포한 위험성 때문이다. 간단하게 보면 상속받은 두 클래스에 같은 동작이 정의되어 있다면 둘 중 어느것을 실행해야 할 지 알 수 없는 문제가 있다.

대신 Java에서는 인터페이스를 제공하여 어떤 '역할'을 객체에게 제공하는데 이는 `is able to`라고 할 수 있을 것이다.

상속 관계의 객체를 생성할 때는 메모리에 부모 객체들(Object 까지)이 등록된다.

# QnA
## 다중 상속의 다이아몬드 문제란?
상속받는 클래스가 같은 메서드를 정의했을 때 이를 구분하기 어렵고 어느 것을 상속받아야 할 지 명확하지 않음.
## 상위 클래스에서 물려주는 특성이 많고 인터페이스에서 강제하는 역할이 적을수록 LSP, ISP를 준수하기 적합한 이유는?
LSP는 부모 타입의 역할을 자식 타입이 문제없이 수행할 수 있어야 하는 것이므로 부모 클래스를 확장하고 재사용하는 부분이 많을수록 좋다. ISP는 인터페이스를 역할에 따라 분리하는 원칙이기 때문에 역할에 따라 세분화하여 기능의 응집도를 높이는 것이 좋다.
## 정적 멤버 참조 시 클래스로 참조하는 것이 메모리 상으로 좋은 이유는?
클라이언트 - 객체(힙) - 클래스(스태틱)보다 클라이언트 - 클래스(스태틱) 접근 방식이 한 단계 더 짧기 때문.
