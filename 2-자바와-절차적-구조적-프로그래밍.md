# 자바와 절차적/구조적 프로그래밍
객체 지향 프로그램의 T 메모리는 코드 실행 영역을 제외하고 Static, Heap, Stack 영역을 의미한다.

자바는 psvm, 즉 `public static void main(String[] args)` 함수를 찾아서 실행하는 방식으로 애플리케이션을 실행한다. 
하지만 그 전에 먼저 JRE가 애플리케이션에서 사용되는 클래스와 import 구문으로 불러오는 다른 클래스들을 Static 영역에 등록한다.
그리고 `main` 메서드에 대한 스택 프레임을 생성해서 메서드를 호출하면서 진행하게 된다.

메서드 파라미터와 메서드 내부에서 사용되는 지역 변수들은 이 스택 프레임에서 생성되고 메서드 호출 종료 시 전부 소멸된다. 분기문을 만난다면 참인 분기문의 스택 프레임만 생성된다.
클래스의 멤버 변수들은 객체가 생성될 때 힙 영역에 포함됐다가 객체가 소멸할 때 같이 사라진다.
클래스의 정적 멤버 변수들은 Static 영역에 객체의 생성, 소멸과 관계없이 항상 존재한다.

메서드 스택 프레임 내부의 변수들끼리는 참조할 수 없음. 그게 가능하려면 포인터를 직접 지원해야 하는데 Java에서는 C/C++과 달리 포인터를 지원하지 않기 때문.
게다가 한 메서드를 호출하는 방식은 여러 경로가 있을 수 있는데 내부 스택 프레임에서 특정 외부 스택 프레임을 참조하면 해당 스택 프레임이 존재하지 않을 수도 있다는 것.
이를 메서드의 '블랙박스'화라고 할 수 있다. 직접적으로 상호작용하지 않고 파라미터와 리턴값으로 통신하는 것이다.

대신 전역 변수를 통해 여러 스택 프레임에서 값을 공유하거나 읽고 쓸 수 있다. 
하지만 애플리케이션의 규모가 커지면서 전역 변수에 대한 접근이 많아질수록 변경 추적이 어려워 버그나 테스트를 까다롭게 할 수 있다.
그렇기 때문에 쓰기 가능한 전역 변수는 최대한 지양하고 상수(final) 값으로 사용하는 것이 좋다.

멀티 스레드 모델은 스택을 스레드 개수만큼 분할해서 사용하며 멀티 프로세스 모델은 이 Static, Heap, Stack 메모리 영역을 가진 프로세스 자체가 여러개 존재하는 모델이다.
당연히 멀티 프로세스는 서로다른 프로세스 간 간섭을 고려할 필요가 없지만 메모리를 많이 차지하며 IPC가 필요하다.
멀티 스레드는 서로다른 스레드가 Heap, Static 영역을 공유하기 때문에 동기화를 고려해야 하지만 메모리를 덜 차지한다.

이전에 언급한 전역 변수에 lock을 거는 방식으로 서로다른 스레드의 접근을 통제한다면 멀티 스레드의 장점을 잃게 된다. 그렇기 때문에 read-only로 사용하라는 것.

자바의 서블릿이 이 멀티 스레드 모델을 채택하여 매 요청마다 스레드를 생성, 스택을 분할하여 사용하는 방식을 채택했다.
