## 객체 지향의 4대 특성 - 캡! 상추다

- 캡슐화(정보 은닉)
- 상속(재사용)
- 추상화(모델링)
- 다형성(사용 편의)

---

## 클래스와 객체 관계

"클래스는 분류에 대한 개념이지 실체가 아니다. 객체는 실체다."

- 객체 : 세상에 존재하는 유일무이한 사물
- 클래스 : 분류, 집합 같은 속성과 기능을 가진 객체를 총칭하는 개념
- cf : 클래스를 이용해 object를 만들었다는 것을 강조할 때는 object라는 표현보다는 클래스의 인스턴스라는 표현을 쓴다.

---

## 추상화: 모델링

### 1. 추상화

- 추상의 의미 : 여러 사물이나 개념에서 **공통되는 특성이나 속성 따위를 추출**하여 파악하는 작용
- 추상화
    - 구체적인 것을 분해해서 관찰자가 관심있는 영역(application boundary)만 가지고 재조합하는 것 → 모델링
    - 모델 : 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것
- 추상화는 모델링이다
    - 객체 지향에서 클래스를 설계할 때, 데이터베이스의 테이블을 설계할 때 필요한 기법 
    (→ 클래스 설계를 위해서는 application boundary부터 정해야 한다.)
    - 객체 지향에서 추상화의 결과는 클래스이다. 
    (자바는 객체 지향의 추상화를 클래스를 통해 지원한다.)
- 추상화의 개념
    - 상속을 통한 추상화, 구체화
    - 인터페이스를 통한 추상화
    - 다형성을 통한 추상화

### 2. 추상화와 T메모리

- 클래스 멤버와 객체 멤버를 구분하는 자바 키워드는 static
    - static이 붙은 속성 = 클래스 멤버 속성
    - static이 안 붙은 속성 = 객체 멤버 속성
- [https://siyoon210.tistory.com/124](https://siyoon210.tistory.com/124)
- **정적 속성 → static 영역**
    - static 정보는 main 메서드가 시작되기 전에 로드되고 main 메서드가 종료되면 없어진다.
    - 정적 멤버 속성은 해당 클래스의 모든 객체들이 같은 값을 가질 때 사용
    - 정적 메서드는 정적멤버속성의 getter, setter 또는 클래스 인스턴스를 만들지 않고 사용하게 되는 유틸리티성 메서드일 때 사용
- **객체 속성 → 힙 영역**
    - 객체가 힙영역에 생성되면 각 객체 안에 멤버 속성을 위한 메모리 공간이 할당된다
- **지역변수 → 스택 영역**
    - 지역변수는 별도로 초기화 해주지 않으면 쓰레기값을 갖는다.
    (멤버변수는 공유 변수의 성격을 가지고 있어서 자동으로 초기화해준다.)

---

## 상속 : 재사용 + 확장

### 1. 상속 : 재사용 + 확장

- 객체지향에서의 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가(확장)해서 사용할 수 있다는 의미다
- 하위 클래스는 상위 클래스다 (LSP)

### 2. 상속은 is a kind of 관계를 만족해야한다.

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야한다.

### 3. 상속과 인터페이스

- 자바는 다중 상속을 포기하고 인터페이스를 도입함.
- 인터페이스는 is a kind of 관계가 아닌 is able to 관계로 상속과 다르게 사용하게 됐다.
    - 자바 API에서 able 형식의 인터페이스를 확인할 수 있음(serializable, cloneable 등)
- ⭐상위 클래스(상속)는 물려줄 특성이 많으면 좋고(LSP), 
인터페이스는 구현을 강제할 메서드의 개수가 적을수록 좋다(ISP)
→ 컴퓨터 프로그램에서 자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등) 의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 치환 할 수 있어야 한다 출처: [https://2dubbing.tistory.com/25](https://2dubbing.tistory.com/25) [비실이의 개발 성장기]

### 4. 상속과 T메모리

- 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 힙 영역에 생성된다.
    - 만약 `Animal pingu = new Penguin();` 이라면 pingu.showHabitat() 메서드를 사용할 수 없다.
    → [https://ok4u.tistory.com/134](https://ok4u.tistory.com/134)
    - 묵시적 형변환 ( UpCasting / Promotion ) : 작은 타입 -> 큰 타입, 프로그램 실행 도중 자동으로 일어난다.
    - 명시적 형변환 ( DownCasting / Casting ) : 큰 타입 -> 작은 타입

---

## 다형성 : 사용편의성

### 1. 오버라이딩과 오버로딩

- 객체지향에서 다형성 = 오버라이딩과 오버로딩
- 오버라이딩 : 같은 메서드 이름, 같은 인자 목록으로 상위 클래스의 메서드를 재정의
    - 상위 클래스 타입의 객체 참조 변수를 사용하더라도 하위 클래스에서 오버라이딩(재정의)한 메서드가 호출된다.
    - [https://velog.io/@maigumi/Dynamic-Method-Dispatch](https://velog.io/@maigumi/Dynamic-Method-Dispatch)
- 오버로딩 : 같은 메서드 이름, 다른 인자 목록으로 다수의 메서드를 중복 정의

### 2. 다형성이 지원되지 않는 언어

- 다형성이 지원되지 않는 언어는 같은 이름의 함수를 추가로 만들 수 없다.
- 함수명 하나를 가지고 인자 목록을 달리하면 되는 오버로딩과 비교해봤을 때 오버로딩이 사용하기 편리한 지 알 수 있음
(cf : 제네릭 또한 함수 하나만 구현해도 다수의 함수를 구현한 효과를 낼 수 있어 편리함)

---
## 캡슐화 : 정보은닉

### 1. 객체 멤버와 정적 멤버의 접근 제어자

- 접근 제어자
    - private : 본인만 접근 가능
    - default : 같은 패키지 내의 클래스에서 접근 가능
    - protected : 상속받은 클래스 또는 같은 패키지 내의 클래스에서 접근 가능
    - public : 모두가 접근 가능
- 상속받지 않았다면 객체 멤버는 객체를 생성한 후 객체 참조 변수를 이용해 접근해야한다.
- 정적 멤버는 클래스명.정적멤버 형식으로 접근하는 것을 권장한다.
    
    - 일관된 형식으로 접근하기 위해서
    - 물리적 접근에 따른 이유

### 2. 참조 변수의 복사

- 기본 자료형 변수는 값을 값 자체로 판단한다
- 참조 자료형 변수는 값을 주소(포인터)로 판단한다
