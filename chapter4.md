[4장 자바가 확장한 객체 지향](https://www.notion.so/4-c413802ee83449548fc2b92a9ede8fef)

## abstract - 추상 메서드와 추상 클래스

- 추상 메서드 : 선언부는 있는데 구현부는 없는 메서드
    - 하위 클래스에게 메서드 구현을 강제한다.
- 추상 클래스 : 추상 메서드를 가진 클래스
    - 인스턴스를 만들 수 없다.

## 생성자

- 객체 생성자 메서드(= 생성자) : 반환값이 없고 클래스 명과 같은 이름을 가진 메서드
- 자바는 알아서 인자가 없는 기본 생성자를 자동으로 만들어준다.
- 인자가 있는 생성자를 하나라도 만들면 자바는 기본 생성자를 만들어 주지 않는다.

## static 블록 - 클래스 생성 시의 실행 블록

- static 블록 : 클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 있다.
- static 블록에서 사용할 수 있는 속성과 메서드는 static 멤버 뿐이다.
(static 블록이 실행될 때 해당 클래스의 객체는 하나도 존재하지 않기 때문에 객체 멤버에 접근할 수 없다.)
- 클래스 정보는 해당 클래스가 코드에서 맨 처음 사용될 때 t메모리의 스태틱 영역에 로딩되며, static 블록은 단 한번만 실행된다.
- cf : 클래스가 처음으로 사용될 때는
    - 클래스의 정적 속성을 사용할 때
    - 클래스의 정적 메서드를 사용할 때
    - 클래스의 인스턴스 만들 때
- static 블록과 유사하게 클래스의 인스턴스를 위한 인스턴스 블록도 존재
→ Initializing Instance Members
    - 아무 표시없이 {} 블록을 사용하면 인스턴스가 생성될 때마다 {} 블록이 실행
    - 객체 생성자가 실행되기 전에 먼저 실행

## final 키워드

### final 클래스

- 상속을 허락하지 않는 클래스

### final 변수

- 변경 불가능한 상수(읽기 전용인 상수)
- 정적 상수는 선언 시에, 또는 정적 생성자에 해당하는 static 블록 내부에서 초기화가 가능

### final 메서드

- 오버라이딩을 금지하는 메서드

❗final 키워드를 많이 사용해야겠다

## Instanceof 연산자

- 만들어진 객체가 특정 클래스의 인스턴스인지 물어보는 연산자
- LSP(리스코프 치환 원칙)을 어기는 코드에서 주로 나타나는 연산자

❓ 왜 어기게 되는걸까?

## package 키워드

- 네임스페이스를 만들어주는 역할 → 이름충돌이 일어나지 않게 함

## interface 키워드와 implements 키워드

- interface는 public 추상 메서드와 public 정적 상수만 가질 수 있기 때문에 
따로 메서드에 public과 abstract를, 속성에 public과 static, final을 붙이지 않아도 자동으로 자바가 알아서 붙여준다.
- 자바8 : 빅데이터와 병렬성 지원을 위해 자바는 컬렉션을 강화하는 수순으로 발전했고, 람다라는 기능을 언어적으로 추가했다.
    - **람다** : **변수에 저장할 수 있는 로직(함수)**으로, 이를 이용해 로직을 메서드의 인자로 쓰거나, 로직을 메서드의 반환값으로 사용할 수 있다.
    - 람다는 인터페이스를 기초하고 있기 때문에 정적 상수와 객체 추상 메서드만 가질 수 있었던 자바8 이전의 interface와 다르게 자바8 이후의 interface는 **디폴트 메서드(객체 구상 메서드, 정적 추상 메서드를 가지는)를 지원한다.**
    
    ❓ 자바에서 병령성이라는 게 어떤거지?
    

## this 키워드

- 지역 변수와 속성(객체 변수, 정적 변수)의 이름이 같은 경우 지역 변수가 우선한다.
- 객체 변수와 이름이 같은 지역 변수가 있는 경우, **객체 변수를 사용하려면 this를 사용**한다.
- 정적 변수와 이름이 같은 지역변수가 있는 경우, **정적 변수를 사용하려면 클래스명을 사용**한다.

## super 키워드

- 단일 상속만을 지원하는 자바에서 super는 바로 위 상위 클래스의 인스턴스를 지칭
- super.super 형태로 상위의 상위 클래스의 인스턴스에는 접근이 불가능하다.

## 예비 고수를 위한 한마디

> 객체 메서드를 호출할 때 스택 정보를 보면 
객체명.객체메서드명()이 아닌 클래스명.객체메서드명() 이다!
> 
- 객체 멤버 메서드는 각 객체별로 달라지는 것이 아니고 객체 멤버의 속성의 값만 다르다
- 똑같은 객체 멤버 메서드를 힙 영역에 객체수 만큼 생성하는 것은 메모리 낭비이기 때문에 jvm은 객체 멤버 메서드를 스태틱 영역에 하나만 보유한다.
