## abstract 키워드 - 추상 메서드와 추상 클래스

추상 클래스는 여러 클래스들 간에 비슷한 필드와 메서드를 공통적으로 추출해 만들어진 클래스다. 아직 메서드와 내용이 추상적이기 때문에 객체를 생성할 수 없게 만들었다.

추상 메서드를 포함하면 클래스 또한 추상 클래스여야 한다.

하위 클래스에게 메서드의 오버라이딩을 강제한다.

## 생성자

생성자의 정확한 명칭은 객체 생성자 메서드라고 한다.

개발자가 따로 만들지 않으면 default로 인자가 없는 기본 생성자를 자동으로 만들어준다. 하지만 인자가 있는 생성자를 하나라도 만든다면 기본 생성자를 (사용할거라면) 따로 생성해야함!

## 클래스 생성 시의 실행 블록, static 블록

클래스가 스태틱 영역에 배치될 때 실행되는 코드 블록이 static 블록이다.

```java
public class 동물 {
	static {
		// 해당 부분
	}
}
```

그렇다면 클래스는 언제 스태틱 영역에 배치될까? 

해당 클래스가 처음으로 사용될 때 로딩되며 단 한번 스태틱 영역에 배치된다. ⇒ **메모리 사용을 최대한 늦추기 위해서!**

- 클래스의 정적 속성을 사용할 때
- 클래스의 정적 메서드를 사용할 때
- 클래스의 인스턴스를 최초로 만들 때

*JUnit의 @BeforeClass 어노테이션?*

## final 키워드

final은 객체 지향 언어의 구성 요소인 클래스, 변수, 메서드에서 나타날 수 있고 선언시에 최초 한 번만 초기화가 가능하다. 상속, 오버라이딩, 값의 변경을 허락하지 않는다.

## instanceof 연산자

객체가 특정 클래스의 인스턴스인지, 또는 특정 인터페이스의 구현체인지 확인할 수 있는 연산자다. 객체 참조 변수의 타입이 아닌 실제 객체의 타입으로 판단해 반환한다.

*LSP를 어기는 코드에서 주로 나타나는 연산자라는데 왜?*

## package 키워드

네임스페이스를 만들어주는 역할을 한다. 

서로 관련이 있는 클래스나 인터페이스를 함께 묶음으로써 파일을 효율적으로 관리할 수 있게 되고 이름 충돌을 피할 수 있다.

## interface 키워드와 implements 키워드

자바의 인터페이스는 public 추상 메서드와 public 정적 상수만 가질 수 있다. 따로 접근 지정자나 final 키워드를 붙이지 않아도 자바가 자동으로 붙여준다.

```java
double PI = 3.14;
void sayYes();

// 같은 코드
public static final double PI = 3.14;
public abstract void sayYes();
```

### *람다(부록B 참고)

빅데이터와 병렬성 지원을 강화한 자바8에서는 컬렉션을 강화하기 위해 람다(Lambda)라고 하는 기능을 언어적으로 추가했다.

람다는 함수를 의미하며 변수에 할당할 수 있다. 즉, 로직을 변수에 저장할 수 있고 메서드의 인자로 쓸 수 있고 반환값으로도 사용할 수 있다.

함수형 언어가 지닌 특성을 자바도 수용했다는 것을 의미한다.

또한, 자바8부터는 디폴트 메서드라고 하는 객체 구상 메서드와 정적 추상 메서드를 지원할 수 있게 바뀌었다.

## this 키워드

객체 자기 자신을 지칭할 때 쓰는 키워드다.

## super 키워드

상위 클래스의 인스턴스를 지칭하는 키워드다.

단, super.super처럼 상위의 상위 클래스의 인스턴스에는 접근이 불가능하다.
